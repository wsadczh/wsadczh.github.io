---
title: 进阶篇
date: 2022-04-21 11:00:19
permalink: /pages/9c29865395124/
categories:
  - 面试突击
tags:
  -
---

【腾讯文档】2、第二部分：进阶篇(30 题).
<https://docs.qq.com/pdf/DV0VDSkZFeVNGZkNy>

<!-- more -->

## JS

### 变量提升

> 当执行 js 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只有这两种执行环境。

```js
b(); // call b
console.log(a); // undefined
var a = "Hello world";
function b() {
  console.log("call b");
}
```

> 想必以上的输出⼤家肯定都已经明⽩了，这是因为函数和变量提升的原因。通
> 常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于⼤
> 家理解。但是更准确的解释应该是：在⽣成执⾏环境时，会有两个阶段。第⼀
> 个阶段是创建的阶段， JS 解释器会找出需要提升的变量和函数，并且给他们
> 提前在内存中开辟好空间，函数的话会将整个函数存⼊内存中，变量只声明并
> 且赋值为 undefined ，所以在第⼆个阶段，也就是代码执⾏阶段，我们可以
> 直接提前使⽤

在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升

```js
b(); // call b second
function b() {
  console.log("call b fist");
}
function b() {
  console.log("call b second");
}
var b = "Hello world";
```

> var 会产⽣很多错误，所以在 ES6 中引⼊了 let 。 let 不能在声明前使
> ⽤，但是这并不是常说的 let 不会提升， let 提升了，在第⼀阶段内存也
> 已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使⽤

### bind、call、apply 区别

call 和 apply 都是为了解决改变 this 的指向。作⽤都是相同的，只是传参的⽅式
不同。

除了第⼀个参数外， call 可以接收⼀个参数列表， apply 只接受⼀个参数数组

```js
let a = {
  value: 1,
};
function getValue(name, age) {
  console.log(name);
  console.log(age);
  console.log(this.value);
}
getValue.call(a, "shenzjd.com", "666");
getValue.apply(a, ["shenzjd.com", "666"]);
```

> bind 和其他两个⽅法作⽤也是⼀致的，只是该⽅法会返回⼀个函数。并且我
> 们可以通过 bind 实现柯⾥化

### 如何实现⼀个 call 函数

```js
Function.prototype.myCall = function (context) {
  var context = context || window;
  // 给 context 添加⼀个属性
  // getValue.call(a, 'yck', '24') => a.fn = getValue
  context.fn = this;
  // 将 context 后⾯的参数取出来
  var args = [...arguments].slice(1);
  // getValue.call(a, 'yck', '24') => a.fn('yck', '24')
  var result = context.fn(...args);
  // 删除 fn
  delete context.fn;
  return result;
};
```

上面的是 yck 写的，但是我更推荐神三元的写法

```js
Function.prototype.call = function (context, ...args) {
  let context = context || window;
  context.fn = this;
  let result = context.fn(...args);
  delete context.fn;
  return result;
};
```

### 如何实现⼀个 apply 函数

```js
Function.prototype.myApply = function (context) {
  var context = context || window;
  context.fn = this;
  var result;
  // 需要判断是否存储第⼆个参数
  // 如果存在，就将第⼆个参数展开
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  delete context.fn;
  return result;
};
```

上面的是 yck 写的，但是我更推荐神三元的写法,这里的 apply 只是接收参数的区别

```js
Function.prototype.apply = function (context, args) {
  let context = context || window;
  context.fn = this;
  let result = context.fn(...args);
  delete context.fn;
  return result;
};
```

### 如何实现⼀个 bind 函数

对于实现以下⼏个函数，可以从⼏个⽅⾯思考

- 不传⼊第⼀个参数，那么默认为 window
- 改变了 this 指向，让新的对象可以执⾏该函数。那么思路是否可以变成给新的对象添加⼀个函数，然后在执⾏完以后删除？

```js
Function.prototype.myBind = function (context) {
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  var _this = this;
  var args = [...arguments].slice(1);
  // 返回⼀个函数
  return function F() {
    // 因为返回了⼀个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments);
    }
    return _this.apply(context, args.concat(...arguments));
  };
};
```

上面的是 yck 写的，但是我更推荐神三元的写法

```js
Function.prototype.bind = function (context, ...args) {
  if (typeof this !== "function") {
    throw new Error("this must be a function");
  }
  var that = this;
  var fbound = function () {
    that.call(context, ...args, arguments);
  };
  if (this.prototype) {
    fbound.prototype = Object.create(this.prototype);
  }
  return fbound;
};
```

更多手写访问：<https://blog.scstudy.site/pages/7a05690c28407/>

### 简单说下原型链

- 每个函数都有 prototype 属性，除了 Function.prototype.bind(),该属性指向原型。
- 每个独享都有\_\_proto\_\_属性，指向了创建该对象的构造函数的原型。其实这个属性指向了[[prototype]]，但是[[prototype]]是内部属性，我们并不能访问到，所以用\_\_proto\_\_来访问。
- 对象可以通过\_\_proto\_\_来寻找不属于该对象的属性，\_\_proto\_\_将对象连接起来组成了原型链

原型链推荐看这个：<https://blog.scstudy.site/pages/680e335c611f2/>

### 箭头函数的特点

```js
function a() {
  return () => {
    return () => {
      console.log(this);
    };
  };
}
console.log(a()()());
```

> 箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外⾯的第⼀
> 个不是箭头函数的函数的 this 。在这个例⼦中，因为调⽤ a 符合前⾯代
> 码中的第⼀个情况，所以 this 是 window 。并且 this ⼀旦绑定了上下
> ⽂，就不会被任何代码改变

### this

```js
function foo() {
  console.log(this.a);
}
var a = 1;
foo(); // 1
var obj = {
  a: 2,
  foo: foo,
};
obj.foo(); // 2

// 以上两者情况 `this` 只依赖于调⽤函数前的对象，优先级是第⼆个情况⼤于第⼀个情况
// 以下情况是优先级最⾼的，`this` 只会绑定在 `c` 上，不会被任何⽅式修改 `this` 指向
var c = new foo();
c.a = 3;
console.log(c.a); // 3
// 还有种就是利⽤ call，apply，bind 改变 this，这个优先级仅次于 new
```

### async,await
